{"text": "Write a function to reverse a linked list.", "code": "class Node: \r\n\tdef __init__(self, val=0, next=None):\r\n\t\tself.val = val\r\n\t\tself.next = next\r\n\r\ndef reverse_linked_list(head):\r\n\tif not head or not head.next:\r\n\t\treturn head\r\n\tnew_head = reverse_linked_list(head.next)\r\n\thead.next.next = head\r\n\thead.next = None\r\n\treturn new_head", "task_id": 975, "test_setup_code": "class TestLinkedList:\n\tdef __init__(self, values):\n\t\tself.head = None\n\t\tif values:\n\t\t\tself.head = Node(values[0])\n\t\t\tcurrent = self.head\n\t\t\tfor value in values[1:]:\n\t\t\t\tcurrent.next = Node(value)\n\t\t\t\tcurrent = current.next\n\n", "test_list": ["linked_list = TestLinkedList([1, 2, 3, 4, 5])\nreverse_linked_list(linked_list.head)\nassert linked_list.head.val == 5\nassert linked_list.head.next.val == 4\nassert linked_list.head.next.next.val == 3\nassert linked_list.head.next.next.next.val == 2\nassert linked_list.head.next.next.next.next.val == 1", "linked_list = TestLinkedList([1, 2, 3])\nreverse_linked_list(linked_list.head)\nassert linked_list.head.val == 3\nassert linked_list.head.next.val == 2\nassert linked_list.head.next.next.val == 1", "linked_list = TestLinkedList([1])\nreverse_linked_list(linked_list.head)\nassert linked_list.head.val == 1"], "challenge_test_list": []}
{"text": "Wrtie a function for two sum question", "code": "def twoSum(nums, target):\n d = {}\n for i, num in enumerate(nums):\n if target - num in d:\n return [d[target - num], i]\n d[num] = i\n return []", "task_id": 1, "test_setup_code": "", "test_list": ["assert twoSum([2,7,11,15], 9) == [0,1]", "assert twoSum([3,2,4], 6) == [1,2]", "assert twoSum([3,3], 6) == [0,1]"], "challenge_test_list": []}
{"text": "Wrtie a function to find the longest palindromic subsequence's length .", "code": "def longestPalindromeSubseq(s: str) -> int: \r\n n = len(s) \r\n dp = [[0]*n for _ in range(n)] \r\n for i in range(n-1, -1, -1): \r\n dp[i][i] = 1 \r\n for j in range(i+1, n): \r\n if s[i] == s[j]: \r\n dp[i][j] = dp[i+1][j-1] + 2 \r\n else: \r\n dp[i][j] = max(dp[i+1][j], dp[i][j-1]) \r\n return dp[0][-1]", "task_id": 1025, "test_setup_code": "", "test_list": ["assert longestPalindromeSubseq('bbbab') == 4", "assert longestPalindromeSubseq('cbbd') == 2", "assert longestPalindromeSubseq('a') == 1"], "challenge_test_list": []}
{"text": "Wrtie a function to find the median of the two sorted arrays.", "code": "", "task_id": 4, "test_setup_code": "", "test_list": ["assert findMedianSortedArrays([1, 3], [2]) == 2.0", "assert findMedianSortedArrays([1, 2], [3, 4]) == 2.5", "assert findMedianSortedArrays([0, 0], [0, 0]) == 0.0", "assert findMedianSortedArrays([], [1]) == 1.0", "assert findMedianSortedArrays([2], []) == 2.0"], "challenge_test_list": []}
{"text": "Write a function to find longest substring without repeating characters.", "code": "def lengthOfLongestSubstring(s):\n chars = {}\n left = 0\n right = 0\n res = 0\n while right < len(s):\n if s[right] in chars and chars[s[right]] >= left:\n left = chars[s[right]] + 1\n chars[s[right]] = right\n res = max(res, right - left + 1)\n right += 1\n return res", "task_id": 3, "test_setup_code": "", "test_list": ["assert lengthOfLongestSubstring('abcabcbb') == 3", "assert lengthOfLongestSubstring('bbbbb') == 1", "assert lengthOfLongestSubstring('pwwkew') == 3"], "challenge_test_list": []}
{"text": "Write a Python function to convert a string into a zigzag pattern based on a given number of rows. ", "code": "def convert(s: str, numRows: int) -> str:\n    if numRows == 1:\n        return s\n    rows = ['' for _ in range(numRows)]\n    row = 0\n    direction = -1\n    for c in s:\n        rows[row] += c\n        if row == 0 or row == numRows - 1:\n            direction *= -1\n        row += direction\n    return ''.join(rows)","test_setup_code": "test_cases = [(\"PAYPALISHIRING\", 3, \"PAHNAPLSIIGYIR\"),\n              (\"PAYPALISHIRING\", 4, \"PINALSIGYAHRPI\"),\n              (\"A\", 1, \"A\")]", "test_list": [], "challenge_test_list": []}
{"text": "Write a function to reverse a given 32-bit signed integer.", "code": "def reverse(x):\n if x >= 0:\n sign = 1\n else:\n sign = -1\n x = -x\n reversed_x = int(str(x)[::-1])\n if reversed_x > (2**31 - 1):\n return 0\n return reversed_x * sign", "task_id": 7, "test_setup_code": "test_cases = [\n (123, 321),\n (-123, -321),\n (120, 21),\n (0, 0)\n]", "test_list": ["for x, expected in test_cases:\n assert reverse(x) == expected"], "challenge_test_list": []}
{"text": "Write a Python function to implement the String to Integer (atoi) conversion.", "code": "class Solution:\n def myAtoi(self, s: str) -> int:\n s = s.strip()\n if not s: return 0\n\n sign = -1 if s[0] == '-' else 1\n if s[0] in ['-', '+']: s = s[1:]\n\n res, i = 0, 0\n while i < len(s) and s[i].isdigit():\n res = res * 10 + ord(s[i]) - ord('0')\n i += 1\n\n return max(-231, min(sign * res, 231 - 1))", "task_id": 875, "test_setup_code": "s = Solution()", "test_list": ["assert s.myAtoi('42') == 42", "assert s.myAtoi(' -42') == -42", "assert s.myAtoi('4193 with words') == 4193", "assert s.myAtoi('words and 987') == 0", "assert s.myAtoi('-91283472332') == -2147483648", "assert s.myAtoi('3.14159') == 3", "assert s.myAtoi('+-12') == 0"], "challenge_test_list": []}
{"text": "Write a function to check if a given integer is a palindrome or not.", "code": "class Solution:\n def isPalindrome(self, x: int) -> bool:\n if x < 0:\n return False\n reverse_x, orig_x = 0, x\n while x > 0:\n reverse_x = reverse_x * 10 + x % 10\n x //= 10\n return reverse_x == orig_x", "task_id": 0, "test_setup_code": "s = Solution()", "test_list": ["assert s.isPalindrome(121) == True", "assert s.isPalindrome(-121) == False", "assert s.isPalindrome(10) == False"], "challenge_test_list": []}
{"text": "Write a function to Regular Expression Matching", "code": "def isMatch(s: str, p: str) -> bool:\n    m, n = len(s), len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n    for j in range(1, n + 1):\n        if p[j - 1] == '*':\n            dp[0][j] = dp[0][j - 1]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if p[j - 1] == '?' or s[i - 1] == p[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            elif p[j - 1] == '*':\n                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n    return dp[m][n]", "task_id": 10, "test_setup_code": "testCases = [(\"aa\", \"a*\", True), (\"mississippi\", \"mis*is*p*.\", False), (\"aab\", \"c*a*b\", True)]", "test_list": ["assert isMatch(testCases[0][0], testCases[0][1]) == testCases[0][2]", "assert isMatch(testCases[1][0], testCases[1][1]) == testCases[1][2]", "assert isMatch(testCases[2][0], testCases[2][1]) == testCases[2][2]"], "challenge_test_list": []}
{"text": "Write a Python function to find the container with the most water ", "code": "def maxArea(height):\n left = 0\n right = len(height)-1\n max_area = 0\n while left < right:\n current_area = min(height[left], height[right]) * (right - left)\n max_area = max(max_area, current_area)\n if height[left] < height[right]:\n left += 1\n else:\n right -= 1\n return max_area", "task_id": 1771, "test_setup_code": "", "test_list": ["assert maxArea([1,8,6,2,5,4,8,3,7]) == 49", "assert maxArea([1,1]) == 1", "assert maxArea([4,3,2,1,4]) == 16"], "challenge_test_list": []}
{"text": "Write a Python function to convert an integer to a roman numeral.", "code": "class Solution:\n def intToRoman(self, num: int) -> str:\n roman_numeral = ''\n roman_numerals = {1000: 'M', 900: 'CM', 500: 'D', 400: 'CD', 100: 'C', 90: 'XC', 50: 'L', 40: 'XL', 10: 'X', 9: 'IX', 5: 'V', 4: 'IV', 1: 'I'}\n for i in roman_numerals:\n while num >= i:\n roman_numeral += roman_numerals[i]\n num -= i\n return roman_numeral", "task_id": 0, "test_setup_code": "", "test_list": ["assert Solution().intToRoman(3) == 'III'", "assert Solution().intToRoman(4) == 'IV'", "assert Solution().intToRoman(9) == 'IX'", "assert Solution().intToRoman(58) == 'LVIII'", "assert Solution().intToRoman(1994) == 'MCMXCIV'"], "challenge_test_list": []}
{"text": "Write a Python function to convert a Roman numeral string to an integer.", "code": "class Solution:\n def romanToInt(self, s: str) -> int:\n symbols = {\n 'I': 1,\n 'V': 5,\n 'X': 10,\n 'L': 50,\n 'C': 100,\n 'D': 500,\n 'M': 1000\n }\n total = 0\n prev = 0\n for c in s:\n current = symbols[c]\n if current > prev:\n total += current - 2 * prev\n else:\n total += current\n prev = current\n return total\n", "task_id": 0, "test_setup_code": "", "test_list": ["assert Solution().romanToInt('III') == 3", "assert Solution().romanToInt('IV') == 4", "assert Solution().romanToInt('IX') == 9", "assert Solution().romanToInt('LVIII') == 58", "assert Solution().romanToInt('MCMXCIV') == 1994"], "challenge_test_list": []}
{"text": "Write a Python function to find the 3sum question", "code": "def threeSum(nums):\n result = []\n nums.sort()\n for i in range(len(nums)-2):\n if i > 0 and nums[i] == nums[i-1]:\n continue\n left, right = i+1, len(nums)-1\n while left < right:\n s = nums[i] + nums[left] + nums[right]\n if s < 0:\n left += 1\n elif s > 0:\n right -= 1\n else:\n result.append([nums[i], nums[left], nums[right]])\n while left < right and nums[left] == nums[left+1]:\n left += 1\n while left < right and nums[right] == nums[right-1]:\n right -= 1\n left += 1\n right -= 1\n return result", "task_id": 984, "test_setup_code": "", "test_list": ["assert sorted(threeSum([-1,0,1,2,-1,-4])) == [[-1,-1,2],[-1,0,1]]", "assert sorted(threeSum([-2,0,0,2,2])) == [[-2,0,2],[0,0,0],[0,2,2]]", "assert threeSum([1,2,-2,-1]) == []"], "challenge_test_list": []}
{"text": "Write a function to find the sum of three integers in a given array closest to a target value.", "code": "def three_sum_closest(nums, target):\n nums.sort()\n res = float('inf')\n n = len(nums)\n for i in range(n-2):\n l, r = i+1, n-1\n while l<r:\n s = nums[i] + nums[l] + nums[r]\n if abs(s-target) < abs(res-target):\n res = s\n if s < target:\n l += 1\n else:\n r -= 1\n return res", "task_id": 155, "test_setup_code": "", "test_list": ["assert three_sum_closest([-1, 2, 1, -4], 1) == 2", "assert three_sum_closest([1, 1, 1, 0], -100) == 2", "assert three_sum_closest([1, 1, -1], 0) == 1"], "challenge_test_list": []}
{"text": "Wrtie a python function for letter combination of a phone number","code": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        if not digits:\n            return []\n        num_to_char = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        result = ['']\n        for digit in digits:\n            temp = []\n            for char in num_to_char[digit]:\n                for combination in result:\n                    temp.append(combination + char)\n            result = temp\n        return result\n", "test_setup_code": "", "test_list": ["assert sol.letterCombinations('23') == ['ad','ae','af','bd','be','bf','cd','ce','cf']","assert sol.letterCombinations('2') == ['a', 'b', 'c']","assert sol.letterCombinations('9') == ['w', 'x', 'y', 'z']"], "challenge_test_list": []}
{"text": "Write a Python function to find all unique quadruplets in the array which gives the sum of target.", "code": "def fourSum(nums, target):\n    nums.sort()\n    result = []\n    for i in range(len(nums)-3):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        for j in range(i+1, len(nums)-2):\n            if j > i+1 and nums[j] == nums[j-1]:\n                continue\n            left = j + 1\n            right = len(nums) - 1\n            while left < right:\n                total = nums[i] + nums[j] + nums[left] + nums[right]\n                if total < target:\n                    left += 1\n                elif total > target:\n                    right -= 1\n                else:\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    while left < right and nums[left] == nums[left+1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right-1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n    return result", "test_setup_code": "from itertools import combinations\nfrom random import randint\n\ndef brute_force(nums, target):\n    result = []\n    for combination in combinations(nums, 4):\n        if sum(combination) == target:\n            result.append(list(combination))\n    return result\n\nnums = [randint(-1000, 1000) for i in range(100)]\ntarget = randint(-5000, 5000)\nexpected = sorted(brute_force(nums, target))", "test_list": ["assert sorted(fourSum(nums, target)) == expected"], "challenge_test_list": []}
{"text": "Write a Python function to find the median of two sorted arrays.", "code": "def findMedianSortedArrays(nums1, nums2):\n    m, n = len(nums1), len(nums2)\n    if m > n:\n        nums1, nums2, m, n = nums2, nums1, n, m\n    i_min, i_max, half_len = 0, m, (m + n + 1) // 2\n    while i_min <= i_max:\n        i = (i_min + i_max) // 2\n        j = half_len - i\n        if i < m and nums2[j - 1] > nums1[i]:\n            i_min = i + 1\n        elif i > 0 and nums1[i - 1] > nums2[j]:\n            i_max = i - 1\n        else:\n            if i == 0:\n                max_of_left = nums2[j - 1]\n            elif j == 0:\n                max_of_left = nums1[i - 1]\n            else:\n                max_of_left = max(nums1[i - 1], nums2[j - 1])\n            if (m + n) % 2 == 1:\n                return max_of_left\n            if i == m:\n                min_of_right = nums2[j]\n            elif j == n:\n                min_of_right = nums1[i]\n            else:\n                min_of_right = min(nums1[i], nums2[j])\n            return (max_of_left + min_of_right) / 2.0", "task_id": 2, "test_setup_code": "", "test_list": ["assert findMedianSortedArrays([1, 3], [2]) == 2.0", "assert findMedianSortedArrays([1, 2], [3, 4]) == 2.5"], "challenge_test_list": []}
{"text": "Write a Python function to merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists.", "code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef mergeTwoLists(l1, l2):\n    if not l1:\n        return l2\n    if not l2:\n        return l1\n    if l1.val <= l2.val:\n        l1.next = mergeTwoLists(l1.next, l2)\n        return l1\n    else:\n        l2.next = mergeTwoLists(l1, l2.next)\n        return l2", "task_id": 3, "test_setup_code": "", "test_list": ["assert mergeTwoLists(ListNode(1, ListNode(2, ListNode(4))), ListNode(1, ListNode(3, ListNode(4)))).val == 1", "assert mergeTwoLists(ListNode(1, ListNode(2, ListNode(4))), ListNode(1, ListNode(3, ListNode(4)))).next.val == 1"], "challenge_test_list": []}
{"text": "Write a Python function to generate all combinations of well-formed parentheses given a number n. Each combination should be a valid parentheses string.", "code": "def generateParenthesis(n):\n    def backtrack(s, left, right):\n        if len(s) == 2 * n:\n            result.append(s)\n            return\n        if left < n:\n            backtrack(s + '(', left + 1, right)\n        if right < left:\n            backtrack(s + ')', left, right + 1)\n\n    result = []\n    backtrack('', 0, 0)\n    return result", "task_id": 4, "test_setup_code": "", "test_list": ["assert generateParenthesis(3) == ['((()))', '(()())', '(())()', '()(())', '()()()']", "assert generateParenthesis(1) == ['()']"], "challenge_test_list": []}
{"text": "Write a Python function to merge k sorted linked lists and return it as a sorted list.", "code": "from heapq import heappush, heappop\n\ndef mergeKLists(lists):\n    heap = []\n    for i, node in enumerate(lists):\n        if node:\n            heappush(heap, (node.val, i))\n    dummy = ListNode(0)\n    curr = dummy\n    while heap:\n        val, i = heappop(heap)\n        curr.next = ListNode(val)\n        curr = curr.next\n        if lists[i].next:\n            lists[i] = lists[i].next\n            heappush(heap, (lists[i].val, i))\n    return dummy.next", "task_id": 3, "test_setup_code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next", "test_list": ["list1 = ListNode(1, ListNode(4, ListNode(5)))\nlist2 = ListNode(1, ListNode(3, ListNode(4)))\nlist3 = ListNode(2, ListNode(6))\nassert mergeKLists([list1, list2, list3]) == [1, 1, 2, 3, 4, 4, 5, 6]", "assert mergeKLists([]) == []"], "challenge_test_list": []}
{"text": "Write a Python function to swap every two adjacent nodes in a linked list and return its head.", "code": "def swapPairs(head):\n    dummy = ListNode(0)\n    dummy.next = head\n    prev = dummy\n    while head and head.next:\n        first_node = head\n        second_node = head.next\n        prev.next = second_node\n        first_node.next = second_node.next\n        second_node.next = first_node\n        prev = first_node\n        head = first_node.next\n    return dummy.next", "task_id": 4, "test_setup_code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next", "test_list": ["list1 = ListNode(1, ListNode(2, ListNode(3, ListNode(4))))\nassert swapPairs(list1) == [2, 1, 4, 3]", "list2 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))\nassert swapPairs(list2) == [2, 1, 4, 3, 5]"], "challenge_test_list": []}
{"text": "Write a Python function to reverse the nodes of a linked list, k nodes at a time, and return its modified head.", "code": "def reverseKGroup(head, k):\n    def reverseList(head):\n        prev = None\n        curr = head\n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n        return prev\n    dummy = ListNode(0)\n    dummy.next = head\n    prev = dummy\n    while head:\n        tail = prev\n        for _ in range(k):\n            tail = tail.next\n            if not tail:\n                return dummy.next\n        next_head = tail.next\n        sub_list_head = head\n        sub_list_tail = tail\n        tail.next = None\n        head = next_head\n        prev.next = reverseList(sub_list_head)\n        sub_list_head.next = head\n        prev = sub_list_tail\n    return dummy.next", "task_id": 5, "test_setup_code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next", "test_list": ["list1 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))\nassert reverseKGroup(list1, 2) == [2, 1, 4, 3, 5]", "list2 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))\nassert reverseKGroup(list2, 3) == [3, 2, 1, 4, 5]"], "challenge_test_list": []}
{"text": "Write a Python function to remove the duplicates in-place from a sorted array and return the new length.", "code": "def removeDuplicates(nums):\n    if not nums:\n        return 0\n    i = 0\n    for j in range(1, len(nums)):\n        if nums[j] != nums[i]:\n            i += 1\n            nums[i] = nums[j]\n    return i + 1", "task_id": 6, "test_setup_code": "", "test_list": ["nums1 = [1, 1, 2]\nassert removeDuplicates(nums1) == 2", "nums2 = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]\nassert removeDuplicates(nums2) == 5"], "challenge_test_list": []}
{"text": "Write a Python function to remove all occurrences of a given value in-place from an array and return the new length.", "code": "def removeElement(nums, val):\n    i = 0\n    for j in range(len(nums)):\n        if nums[j] != val:\n            nums[i] = nums[j]\n            i += 1\n    return i", "task_id": 7, "test_setup_code": "", "test_list": ["nums1 = [3, 2, 2, 3]\nval1 = 3\nassert removeElement(nums1, val1) == 2", "nums2 = [0, 1, 2, 2, 3, 0, 4, 2]\nval2 = 2\nassert removeElement(nums2, val2) == 5"], "challenge_test_list": []}
{"text": "Write a Python function to find the index of the first occurrence of a substring in a given string, or return -1 if the substring is not found.", "code": "def strStr(haystack, needle):\n    if needle == '':\n        return 0\n    for i in range(len(haystack) - len(needle) + 1):\n        if haystack[i:i+len(needle)] == needle:\n            return i\n    return -1", "task_id": 8, "test_setup_code": "", "test_list": ["haystack1 = 'hello'\nneedle1 = 'll'\nassert strStr(haystack1, needle1) == 2", "haystack2 = 'aaaaa'\nneedle2 = 'bba'\nassert strStr(haystack2, needle2) == -1"], "challenge_test_list": []}
{"text": "Write a Python function to divide two integers without using multiplication, division, and mod operator. Return the quotient as an integer.", "code": "def divide(dividend, divisor):\n    if dividend == 0:\n        return 0\n    if divisor == 1:\n        return dividend\n    if divisor == -1:\n        if dividend == -2147483648:\n            return 2147483647\n        return -dividend\n    sign = -1 if (dividend < 0) ^ (divisor < 0) else 1\n    dividend = abs(dividend)\n    divisor = abs(divisor)\n    quotient = 0\n    while dividend >= divisor:\n        dividend -= divisor\n        quotient += 1\n    return sign * quotient", "task_id": 9, "test_setup_code": "", "test_list": ["assert divide(10, 3) == 3", "assert divide(7, -3) == -2"], "challenge_test_list": []}
{"text": "You are given a string s and an array of strings words of the same length. Return all starting indices of substring(s) in s that is a concatenation of each word in words exactly once, in any order, and without any intervening characters.\n\nYou can return the answer in any order.\n\nExample 1:\n\nInput: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\nOutput: [0,9]\nExplanation: Substrings starting at index 0 and 9 are \"barfoo\" and \"foobar\" respectively.\n\nExample 2:\n\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\nOutput: []\nExplanation: There are no substrings in s that are a concatenation of each word in words.\n\nExample 3:\n\nInput: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\nOutput: [6,9,12]\nExplanation: Substrings starting at index 6, 9, and 12 are \"foobar\", \"foobar\", and \"foo\" respectively.\n\nConstraints:\n\n1 <= s.length <= 10^4\ns consists of lower-case English letters.\n1 <= words.length <= 5000\n1 <= words[i].length <= 30\nwords[i] consists of lower-case English letters.\n", "code": "from collections import Counter\n\ndef findSubstring(s, words):\n    if not s or not words:\n        return []\n\n    word_len = len(words[0])\n    word_count = len(words)\n    window_len = word_len * word_count\n    n = len(s)\n    result = []\n\n    word_freq = Counter(words)\n\n    for i in range(n - window_len + 1):\n        seen = Counter()\n        j = 0\n\n        while j < window_len:\n            word = s[i + j:i + j + word_len]\n\n            if word in word_freq:\n                seen[word] += 1\n\n                if seen[word] > word_freq[word]:\n                    break\n\n                j += word_len\n            else:\n                break\n\n        if seen == word_freq:\n            result.append(i)\n\n    return result\n", "task_id": 30, "test_setup_code": "", "test_list": [], "challenge_test_list": []}
{"text": "Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\n\nIf such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).\n\nThe replacement must be in place and use only constant extra memory.\n\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: [1,3,2]\n\nExample 2:\n\nInput: nums = [3,2,1]\nOutput: [1,2,3]\n\nExample 3:\n\nInput: nums = [1,1,5]\nOutput: [1,5,1]\n\nExample 4:\n\nInput: nums = [1]\nOutput: [1]\n\nConstraints:\n\n1 <= nums.length <= 100\n0 <= nums[i] <= 100\n", "code": "def nextPermutation(nums):\n    n = len(nums)\n    i = n - 2\n\n    while i >= 0 and nums[i] >= nums[i + 1]:\n        i -= 1\n\n    if i >= 0:\n        j = n - 1\n\n        while j > i and nums[j] <= nums[i]:\n            j -= 1\n\n        nums[i], nums[j] = nums[j], nums[i]\n\n    nums[i + 1:] = reversed(nums[i + 1:])\n\n    return nums\n", "task_id": 31, "test_setup_code": "", "test_list": [], "challenge_test_list": []}
{"text": "Write a Python function to find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once, and without any intervening characters.\n\nExample 1:\n\nInput: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\nOutput: [0,9]\nExplanation: Substrings starting at index 0 and 9 are \"barfoo\" and \"foobar\" respectively.\n\nExample 2:\n\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\nOutput: []\n\nConstraints:\n\n1 <= s.length <= 10^4\ns consists of lower-case English letters.\n1 <= words.length <= 5000\n1 <= words[i].length <= 30\nwords[i] consists of lower-case English letters.\n", "code": "def findSubstring(s, words):\n    if not s or not words:\n        return []\n    word_len = len(words[0])\n    window_len = len(words) * word_len\n    word_count = {}\n    for word in words:\n        word_count[word] = word_count.get(word, 0) + 1\n    result = []\n    for i in range(len(s) - window_len + 1):\n        window = s[i:i+window_len]\n        temp_count = word_count.copy()\n        j = 0\n        while j < window_len:\n            curr_word = window[j:j+word_len]\n            if curr_word in temp_count and temp_count[curr_word] > 0:\n                temp_count[curr_word] -= 1\n                j += word_len\n            else:\n                break\n        if j == window_len:\n            result.append(i)\n    return result\n", "task_id": 30, "test_setup_code": "", "test_list": [], "challenge_test_list": []}
{"text": "Write a Python function to find the next permutation of a given list of integers in place, such that the permutation is in the ascending order.\n\nIf such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).\n\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: [1,3,2]\n\nExample 2:\n\nInput: nums = [3,2,1]\nOutput: [1,2,3]\n\nExample 3:\n\nInput: nums = [1,1,5]\nOutput: [1,5,1]\n\nExample 4:\n\nInput: nums = [1]\nOutput: [1]\n\nConstraints:\n\n1 <= nums.length <= 100\n0 <= nums[i] <= 100\n", "code": "def nextPermutation(nums):\n    i = len(nums) - 2\n    while i >= 0 and nums[i] >= nums[i+1]:\n        i -= 1\n    if i >= 0:\n        j = len(nums) - 1\n        while nums[j] <= nums[i]:\n            j -= 1\n        nums[i], nums[j] = nums[j], nums[i]\n    left = i + 1\n    right = len(nums) - 1\n    while left < right:\n        nums[left], nums[right] = nums[right], nums[left]\n        left += 1\n        right -= 1\n    return nums\n", "task_id": 31, "test_setup_code": "", "test_list": [], "challenge_test_list": []}
